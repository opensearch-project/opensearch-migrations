/**
 * This gradle file is purely to facilitate building an openapi spec.
 * The Dockerfile does NOT create a final image used by the MA runtime,
 * but it is rather a build step to codify how we're extracting schema information
 * for downstream steps - specifically to create network clients.
 *
 * To build the console_link code and its dependencies into the migration_console
 * image, use the gradle project further up the tree.
 */

plugins {
    id 'base'
}

def openapiOutFile = layout.buildDirectory.file("openapi.json")

def pythonSources = fileTree(dir: projectDir, include: '**/*.py')
def dependencyFiles = files(
    "Pipfile",
    "Pipfile.lock",
    "setup.py",
    "Dockerfile.openapi"
).filter { it.exists() }

// Needed dereferenced pointer for configuration cache
def projectDirRef = projectDir
def dockerImageName = "console-link-openapi-generator:latest"

tasks.register('buildOpenApiDockerImage') {
    mustRunAfter tasks.named('spotlessCheck')
    mustRunAfter tasks.named('spotlessApply')
    inputs.files(pythonSources)
    inputs.files(dependencyFiles)
    outputs.upToDateWhen {
        // Check if Docker image exists, with error handling
        try {
            def proc = ['docker', 'images', '-q', dockerImageName].execute()
            proc.waitFor()
            def imageId = proc.text.trim()
            return !imageId.isEmpty()
        } catch (Exception e) {
            logger.error("Failed to check if Docker image exists. Is Docker installed and running? Error: ${e.message}")
            return false
        }
    }

    doLast {
        def buildCommand = [
            'docker', 'build',
            '-f', 'Dockerfile.openapi',
            '-t', dockerImageName,
            '.'
        ]
        def env = System.getenv().collect { k, v -> "$k=$v" }
        env.removeAll { it.startsWith('DOCKER_API_VERSION=') }
        env.add('DOCKER_API_VERSION=1.44')
        def proc = buildCommand.execute(env, projectDirRef)
        def stdout = new StringBuilder()
        def stderr = new StringBuilder()
        proc.consumeProcessOutput(stdout, stderr)
        def exitCode = proc.waitFor()

        if (stdout) {
            logger.lifecycle("Docker build stdout:\n${stdout}")
        }
        if (stderr) {
            logger.lifecycle("Docker build stderr:\n${stderr}")
        }

        if (exitCode != 0) {
            throw new GradleException("Docker image build failed with exit code $exitCode")
        }
        logger.lifecycle("Docker image built: ${dockerImageName}")
    }
}

tasks.register('generateOpenApiSpec') {
    dependsOn 'buildOpenApiDockerImage'
    doLast {
        def outputFile = openapiOutFile.get().asFile
        outputFile.parentFile.mkdirs()

        def runCommand = [
            'docker', 'run', '--rm',
            dockerImageName
        ]

        def proc = runCommand.execute(null, projectDirRef)
        def stdout = new ByteArrayOutputStream()
        def stderr = new ByteArrayOutputStream()

        proc.consumeProcessOutput(stdout, stderr)
        def exitCode = proc.waitFor()

        if (exitCode != 0) {
            logger.error("Failed to generate OpenAPI spec:\n${stderr.toString("UTF-8")}")
            throw new GradleException("OpenAPI generation failed with exit code $exitCode")
        }

        outputFile.text = stdout.toString("UTF-8")
        logger.lifecycle("OpenAPI spec generated at ${outputFile}")
    }
    inputs.files(pythonSources)
    inputs.files(dependencyFiles)
    outputs.file(openapiOutFile)
}

tasks.register('cleanDockerImage') {
    doLast {
        // Remove the Docker image
        def removeCommand = ['docker', 'rmi', dockerImageName]
        def proc = removeCommand.execute(null, projectDirRef)
        proc.waitFor()
        def stdout = new ByteArrayOutputStream()
        def stderr = new ByteArrayOutputStream()
        proc.consumeProcessOutput(stdout, stderr)
        def exitCode = proc.waitFor()
        if (exitCode == 0) {
            logger.lifecycle("Cleaned Docker image: ${dockerImageName}")
        } else {
            def errMsg = stderr.toString("UTF-8")
            if (errMsg.contains("No such image") || errMsg.contains("Error: No such image")) {
                logger.info("Docker image not found (already removed): ${dockerImageName}")
            } else {
                logger.error("Failed to remove Docker image: ${dockerImageName}\n${errMsg}")
                throw new GradleException("Failed to remove Docker image: ${dockerImageName}")
            }
        }
    }
}

clean.dependsOn('cleanDockerImage')
