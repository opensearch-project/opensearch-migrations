import org.opensearch.migrations.image.RegistryImageBuildUtils
import org.opensearch.migrations.image.ImageRegistryFormatterFactory

def registryEndpoint = rootProject.hasProperty('registryEndpoint') ? rootProject.property('registryEndpoint') : 'localhost:5001'
rootProject.ext.registryEndpoint = registryEndpoint
// buildkit names will be resolved from within the container, so localhost needs to be mapped to whatever this
// is for that container.  This is a hack and should be parameterized.
def buildKitRegistryEndpoint = registryEndpoint == "localhost:5001" ? 'docker-registry:5000' : registryEndpoint
rootProject.ext.buildKitRegistryEndpoint = buildKitRegistryEndpoint
def publishStyle = (rootProject.findProperty("publishStyle") ?: "paths").toString()
def publishedRepoByImageName = [
        migration_console     : "opensearch-migrations-console",
        traffic_replayer      : "opensearch-migrations-traffic-replayer",
        capture_proxy         : "opensearch-migrations-traffic-capture-proxy",
        reindex_from_snapshot : "opensearch-migrations-reindex-from-snapshot",
]

def getRepoNameIfPublishing = { Map cfg ->
    if (publishStyle != 'separateRepos') return null
    def imageName = cfg.get('imageName')?.toString()
    if (!imageName) return null
    return publishedRepoByImageName[imageName]
}

def jibProjects = [
        "TrafficCapture:trafficReplayer": [
                baseImageName : "amazoncorretto",
                baseImageTag  : "17-al2023-headless",
                imageName     : "traffic_replayer",
                imageTag      : "latest",
                requiredDependencies: [
                    ":TrafficCapture:trafficReplayer": ["copyVersionFile_traffic_replayer"]
                ]
        ],
        "TrafficCapture:trafficCaptureProxyServer": [
                baseImageRegistryEndpoint: rootProject.ext.registryEndpoint,
                baseImageGroup : "migrations",
                baseImageName  : "capture_proxy_base",
                baseImageTag   : "latest",
                imageName      : "capture_proxy",
                imageTag       : "latest",
                requiredDependencies: [
                    "": ["buildKit_captureProxyBase"],
                    ":TrafficCapture:trafficCaptureProxyServer": ["copyVersionFile_capture_proxy"]
                ]
        ]
]
jibProjects.values().each { cfg ->
    cfg.repoName = getRepoNameIfPublishing(cfg)
}

def formatter = ImageRegistryFormatterFactory.getFormatter(rootProject.ext.buildKitRegistryEndpoint)
def buildKitProjects = [
        [
                serviceName: "elasticsearchTestConsole",
                contextDir: "TrafficCapture/dockerSolution/src/main/docker/elasticsearchTestConsole",
                imageName:  "elasticsearch_test_console",
                imageTag:   "latest"
        ],
        [
                serviceName: "captureProxyBase",
                contextDir: "TrafficCapture/dockerSolution/src/main/docker/captureProxyBase",
                imageName:  "capture_proxy_base",
                imageTag:   "latest"
        ],
        [
                serviceName: "reindexFromSnapshot",
                contextDir: "DocumentsFromSnapshotMigration/docker",
                imageName:  "reindex_from_snapshot",
                imageTag:   "latest",
                requiredDependencies: [
                        ":DocumentsFromSnapshotMigration:copyDockerRuntimeJars",
                        ":DocumentsFromSnapshotMigration:copyVersionFile_reindexFromSnapshot"
                ]
        ],
        [
                serviceName: "migrationConsoleBase",
                contextDir: "migrationConsole/build/dockerContext",
                imageName:  "migration_console_base",
                imageTag:   "latest",
                buildArgs: [
                        BASE_IMAGE: formatter.getFullBaseImageIdentifier(rootProject.ext.buildKitRegistryEndpoint,
                                "migrations", "elasticsearch_test_console", "latest")
                ],
                requiredDependencies: [
                        ":migrationConsole:syncDockerBuildContext",
                        "buildKit_elasticsearchTestConsole" // All buildKit projects are configured at the root
                ]
        ],
        [
                serviceName: "migrationConsole",
                contextDir: "TrafficCapture/dockerSolution/build/docker/migration_console_staging",
                imageName:  "migration_console",
                imageTag:   "latest",
                buildArgs: [
                        BASE_IMAGE: formatter.getFullBaseImageIdentifier(rootProject.ext.buildKitRegistryEndpoint,
                                "migrations", "migration_console_base", "latest")
                ],
                requiredDependencies: [
                        ":TrafficCapture:dockerSolution:syncArtifact_migration_console_staging_noDockerBuild",
                        "buildKit_migrationConsoleBase" // All buildKit projects are configured at the root
                ]
        ],
        // Not required for main MA operations, but has been helpful for creating test scenarios
        [
                serviceName: "elasticsearchWithSearchGuard",
                contextDir: "TrafficCapture/dockerSolution/src/main/docker/elasticsearchWithSearchGuard",
                imageName:  "elasticsearch_searchguard",
                imageTag:   "latest"
        ]
]

buildKitProjects.each { cfg ->
    cfg.repoName = getRepoNameIfPublishing(cfg)
}

gradle.projectsEvaluated {
    def imageHelper = new RegistryImageBuildUtils()
    imageHelper.registerLoginTask(rootProject)
    imageHelper.applyJibConfigurations(rootProject, jibProjects)
    imageHelper.applyBuildKitConfigurations(rootProject, buildKitProjects)
}

tasks.register("jibAll") {
    group = "build"
    description = "Build all Jib multi-arch images in all subprojects"
    dependsOn rootProject.subprojects.collect { proj ->
        proj.tasks.matching { it.name == "jib" }
    }.flatten()
}

tasks.register("jibAll_amd64") {
    group = "build"
    description = "Build all Jib amd64 images in all subprojects"
    dependsOn rootProject.subprojects.collect { proj ->
        proj.tasks.matching { it.name == "jib_amd64" }
    }.flatten()
}

tasks.register("jibAll_arm64") {
    group = "build"
    description = "Build all Jib arm64 images in all subprojects"
    dependsOn rootProject.subprojects.collect { proj ->
        proj.tasks.matching { it.name == "jib_arm64" }
    }.flatten()
}

tasks.register("buildKitAll") {
    group = "build"
    description = "Build all BuildKit multi-arch images"
    dependsOn rootProject.tasks.matching {
        it.name.startsWith("buildKit_") &&
                !it.name.endsWith("_amd64") &&
                !it.name.endsWith("_arm64")
    }
}

tasks.register("buildKitAll_amd64") {
    group = "build"
    description = "Build all BuildKit amd64 images"
    dependsOn rootProject.tasks.matching {
        it.name.startsWith("buildKit_") && it.name.endsWith("_amd64")
    }
}

tasks.register("buildKitAll_arm64") {
    group = "build"
    description = "Build all BuildKit arm64 images"
    dependsOn rootProject.tasks.matching {
        it.name.startsWith("buildKit_") && it.name.endsWith("_arm64")
    }
}

tasks.register("buildImagesToRegistry") {
    group = "build"
    description = "Build all multi-arch images to registry: ${registryEndpoint}"
    println "buildImagesToRegistry will build images to registry: ${registryEndpoint} with buildKit container using registry: ${buildKitRegistryEndpoint}"
    dependsOn("buildKitAll")
    dependsOn("jibAll")
}

tasks.register("buildImagesToRegistry_amd64") {
    group = "build"
    description = "Build all amd64 images to registry: ${registryEndpoint}"
    println "buildImagesToRegistry_amd64 will build amd64 images to registry: ${registryEndpoint} with buildKit container using registry: ${buildKitRegistryEndpoint}"
    dependsOn("buildKitAll_amd64")
    dependsOn("jibAll_amd64")
}

tasks.register("buildImagesToRegistry_arm64") {
    group = "build"
    description = "Build all arm64 images to registry: ${registryEndpoint}"
    println "buildImagesToRegistry_arm64 will build arm64 images to registry: ${registryEndpoint} with buildKit container using registry: ${buildKitRegistryEndpoint}"
    dependsOn("buildKitAll_arm64")
    dependsOn("jibAll_arm64")
}
