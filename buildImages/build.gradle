import org.opensearch.migrations.image.RegistryImageBuildUtils
import org.opensearch.migrations.image.RegistryImageBuildUtils.Registry

def publishedUrl = rootProject.findProperty('registryEndpoint') ?: 'localhost:5001'
def intermediateUrl = rootProject.findProperty('intermediateRegistry') ?: publishedUrl

def publishedRegistry = new Registry(publishedUrl.toString())
def intermediateRegistry = new Registry(intermediateUrl.toString())

def publishStyle = (rootProject.findProperty("publishStyle") ?: "paths").toString()
def publishedRepoByImageName = [
        migration_console     : "opensearch-migrations-console",
        traffic_replayer      : "opensearch-migrations-traffic-replayer",
        capture_proxy         : "opensearch-migrations-traffic-capture-proxy",
        reindex_from_snapshot : "opensearch-migrations-reindex-from-snapshot",
]

def getRepoNameIfPublishing = { Map cfg ->
    if (publishStyle != 'separateRepos') return null
    def imageName = cfg.get('imageName')?.toString()
    if (!imageName) return null
    return publishedRepoByImageName[imageName]
}

def jibProjects = [
        "TrafficCapture:trafficReplayer": [
                baseImageRegistryEndpoint: "mirror.gcr.io",
                baseImageGroup : "library",
                baseImageName : "amazoncorretto",
                baseImageTag  : "17-al2023-headless",
                imageName     : "traffic_replayer",
                imageTag      : "latest",
                requiredDependencies: [
                    ":TrafficCapture:trafficReplayer": ["syncVersionFile_traffic_replayer"]
                ]
        ],
        "TrafficCapture:trafficCaptureProxyServer": [
                baseImageRegistryEndpoint: intermediateRegistry.hostUrl,
                baseImageGroup : "migrations",
                baseImageName  : "capture_proxy_base",
                baseImageTag   : "latest",
                imageName      : "capture_proxy",
                imageTag       : "latest",
                requiredDependencies: [
                    "": ["buildKit_captureProxyBase"],
                    ":TrafficCapture:trafficCaptureProxyServer": ["syncVersionFile_capture_proxy"]
                ]
        ]
]
jibProjects.values().each { cfg ->
    cfg.repoName = getRepoNameIfPublishing(cfg)
}

def buildKitProjects = [
        [
                serviceName: "elasticsearchTestConsole",
                contextDir: "TrafficCapture/dockerSolution/src/main/docker/elasticsearchTestConsole",
                imageName:  "elasticsearch_test_console",
                imageTag:   "latest"
        ],
        [
                serviceName: "captureProxyBase",
                contextDir: "TrafficCapture/dockerSolution/src/main/docker/captureProxyBase",
                imageName:  "capture_proxy_base",
                imageTag:   "latest"
        ],
        [
                serviceName: "reindexFromSnapshot",
                contextDir: "DocumentsFromSnapshotMigration/docker",
                imageName:  "reindex_from_snapshot",
                imageTag:   "latest",
                requiredDependencies: [
                        ":DocumentsFromSnapshotMigration:copyDockerRuntimeJars",
                        ":DocumentsFromSnapshotMigration:syncVersionFile_reindexFromSnapshot"
                ]
        ],
        [
                serviceName: "migrationConsoleBase",
                contextDir: "migrationConsole/build/dockerContext",
                imageName:  "migration_console_base",
                buildArgs: [
                        BASE_IMAGE: RegistryImageBuildUtils.resolveBaseImage(
                                intermediateRegistry, "migrations", "elasticsearch_test_console", "latest")
                ],
                requiredDependencies: [
                        ":migrationConsole:syncDockerBuildContext",
                        "buildKit_elasticsearchTestConsole" // All buildKit projects are configured at the root
                ]
        ],
        [
                serviceName: "migrationConsole",
                contextDir: "TrafficCapture/dockerSolution/build/docker/migration_console_staging",
                imageName:  "migration_console",
                imageTag:   "latest",
                buildArgs: [
                        BASE_IMAGE: RegistryImageBuildUtils.resolveBaseImage(
                                intermediateRegistry, "migrations", "migration_console_base", "latest")
                ],
                requiredDependencies: [
                        ":TrafficCapture:dockerSolution:syncArtifact_migration_console_staging_noDockerBuild",
                        "buildKit_migrationConsoleBase" // All buildKit projects are configured at the root
                ]
        ],
        // Not required for main MA operations, but has been helpful for creating test scenarios
        [
                serviceName: "elasticsearchWithSearchGuard",
                contextDir: "TrafficCapture/dockerSolution/src/main/docker/elasticsearchWithSearchGuard",
                imageName:  "elasticsearch_searchguard"
        ],
        [
                serviceName: "snapshotFuse",
                contextDir: "fuse-lucene",
                imageName:  "snapshot_fuse",
                imageTag:   "latest"
        ]
]

buildKitProjects.each { cfg ->
    cfg.repoName = getRepoNameIfPublishing(cfg)
}

gradle.projectsEvaluated {
    def imageHelper = new RegistryImageBuildUtils()

    imageHelper.registerLoginTask(rootProject, publishedRegistry)

    imageHelper.applyBuildKitConfigurations(
            rootProject,
            buildKitProjects,
            publishedRegistry,
            intermediateRegistry
    )
    imageHelper.applyJibConfigurations(
            rootProject,
            jibProjects,
            publishedRegistry,
            intermediateRegistry
    )
}

tasks.register("jibAll") {
    group = "build"
    description = "Build all Jib multi-arch images in all subprojects"
    dependsOn rootProject.subprojects.collect { proj ->
        proj.tasks.matching { it.name == "jib" }
    }.flatten()
}

tasks.register("jibAll_amd64") {
    group = "build"
    description = "Build all Jib amd64 images in all subprojects"
    dependsOn rootProject.subprojects.collect { proj ->
        proj.tasks.matching { it.name == "jib_amd64" }
    }.flatten()
}

tasks.register("jibAll_arm64") {
    group = "build"
    description = "Build all Jib arm64 images in all subprojects"
    dependsOn rootProject.subprojects.collect { proj ->
        proj.tasks.matching { it.name == "jib_arm64" }
    }.flatten()
}

tasks.register("buildKitAll") {
    group = "build"
    description = "Build all BuildKit multi-arch images"
    dependsOn rootProject.tasks.matching {
        it.name.startsWith("buildKit_") &&
                !it.name.endsWith("_amd64") &&
                !it.name.endsWith("_arm64")
    }
}

tasks.register("buildKitAll_amd64") {
    group = "build"
    description = "Build all BuildKit amd64 images"
    dependsOn rootProject.tasks.matching {
        it.name.startsWith("buildKit_") && it.name.endsWith("_amd64")
    }
}

tasks.register("buildKitAll_arm64") {
    group = "build"
    description = "Build all BuildKit arm64 images"
    dependsOn rootProject.tasks.matching {
        it.name.startsWith("buildKit_") && it.name.endsWith("_arm64")
    }
}

tasks.register("buildImagesToRegistry") {
    group = "build"
    description = "Build all multi-arch images to registry: ${publishedRegistry}"
    println "buildImagesToRegistry will build images to registry: ${publishedRegistry}"
    dependsOn("buildKitAll")
    dependsOn("jibAll")
}

tasks.register("buildImagesToRegistry_amd64") {
    group = "build"
    description = "Build all amd64 images to registry: ${publishedRegistry}"
    println "buildImagesToRegistry_amd64 will build amd64 images to registry: ${publishedRegistry}"
    dependsOn("buildKitAll_amd64")
    dependsOn("jibAll_amd64")
}

tasks.register("buildImagesToRegistry_arm64") {
    group = "build"
    description = "Build all arm64 images to registry: ${publishedRegistry}"
    println "buildImagesToRegistry_arm64 will build arm64 images to registry: ${publishedRegistry}"
    dependsOn("buildKitAll_arm64")
    dependsOn("jibAll_arm64")
}
