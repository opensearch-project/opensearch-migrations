# Plan: Air-gapped / Private ECR Image & Chart Mirroring (v3)

## Goal

Enable Migration Assistant deployment on isolated subnets (no internet) by mirroring
all required container images and helm charts to a private ECR registry.

Deliver two scripts (packaged in the helm chart tgz):
1. **`generate-private-ecr-values.sh`** — given an ECR registry, generates a helm values
   override file that rewrites all image and chart repository references to ECR.
2. **`mirror-to-ecr.sh`** — copies all required images and charts from public registries
   to the private ECR, using `crane` for images and `helm push` for charts.

Both scripts are version-locked to the chart release — the exact images and chart versions
are hardcoded, not discovered at runtime.

## Chart Categories

**Production** (required for migration):
- cert-manager (dependency for otel-operator)
- strimzi-kafka-operator (kafka for traffic capture)
- argo-workflows (workflow orchestration)
- fluent-bit (log aggregation)
- kube-prometheus-stack (metrics/monitoring)
- otel-collector-daemonset (observability)

**Development** (not mirrored):
- etcd-operator (going away in upcoming merge)
- kyverno (minikube only)
- localstack (local AWS emulation)
- grafana (dashboards)
- jaeger (tracing)
- gatekeeper (not implemented)

## Deliverables

### 1. Image & chart manifest (`scripts/private-ecr-manifest.sh`)

A shell-sourceable file that defines all images and charts to mirror, version-locked:

```bash
# Auto-generated from static analysis of helm charts.
# To regenerate: ./scripts/discover-images.sh

# Production helm charts (name version repository)
CHARTS=(
  "cert-manager 1.17.2 https://charts.jetstack.io"
  "strimzi-kafka-operator 0.47.0 https://strimzi.io/charts/"
  "argo-workflows 0.47.1 https://argoproj.github.io/argo-helm"
  "fluent-bit 0.49.0 https://fluent.github.io/helm-charts"
  "kube-prometheus-stack 72.0.0 https://prometheus-community.github.io/helm-charts"
)

# Container images (full reference including tag)
IMAGES=(
  # cert-manager
  "quay.io/jetstack/cert-manager-controller:v1.17.2"
  "quay.io/jetstack/cert-manager-webhook:v1.17.2"
  "quay.io/jetstack/cert-manager-cainjector:v1.17.2"
  "quay.io/jetstack/cert-manager-startupapicheck:v1.17.2"

  # strimzi
  "quay.io/strimzi/operator:0.47.0"
  "quay.io/strimzi/kafka:0.47.0-kafka-3.9.0"  # runtime image

  # argo-workflows
  "quay.io/argoproj/workflow-controller:v3.7.9"
  "quay.io/argoproj/argocli:v3.7.9"
  "quay.io/argoproj/argoexec:v3.7.9"

  # fluent-bit
  "cr.fluentbit.io/fluent/fluent-bit:4.0.1"

  # kube-prometheus-stack
  "quay.io/prometheus/prometheus:v3.2.1"
  "quay.io/prometheus-operator/prometheus-operator:v0.82.0"
  "quay.io/prometheus/node-exporter:v1.9.0"
  "registry.k8s.io/kube-state-metrics/kube-state-metrics:v2.15.0"
  "quay.io/prometheus-operator/prometheus-config-reloader:v0.82.0"

  # otel
  "public.ecr.aws/aws-observability/aws-otel-collector:v0.43.3"

  # MA images (from public ECR, version set by RELEASE_VERSION)
  "public.ecr.aws/opensearchproject/opensearch-migrations-traffic-capture-proxy:VERSION"
  "public.ecr.aws/opensearchproject/opensearch-migrations-traffic-replayer:VERSION"
  "public.ecr.aws/opensearchproject/opensearch-migrations-reindex-from-snapshot:VERSION"
  "public.ecr.aws/opensearchproject/opensearch-migrations-console:VERSION"

  # Direct template references
  "amazon/aws-cli:2.25.11"
)
```

### 2. `scripts/discover-images.sh`

A developer tool that regenerates the manifest by:
1. Running `helm template` for each production chart with its values
2. Grepping for `image:` references
3. Cross-referencing with known runtime images (strimzi kafka, etc.)
4. Outputting the manifest format

This is run by developers when chart versions change, not by end users.
We can also use the `helm-images` plugin as a cross-check.

### 3. `scripts/mirror-to-ecr.sh`

Sources the manifest, then:

```bash
# Install crane if missing
install_crane() { ... }

# Mirror charts
for entry in "${CHARTS[@]}"; do
  read -r name version repo <<< "$entry"
  helm pull "$name" --repo "$repo" --version "$version"
  aws ecr create-repository --repository-name "charts/$name" 2>/dev/null || true
  helm push "${name}-${version}.tgz" "oci://${ECR_REGISTRY}/charts"
  rm "${name}-${version}.tgz"
done

# Mirror images
for image in "${IMAGES[@]}"; do
  # Parse registry/path:tag
  ecr_path="mirrored/${image%%:*}"
  aws ecr create-repository --repository-name "$ecr_path" 2>/dev/null || true
  crane copy "$image" "${ECR_REGISTRY}/${ecr_path}:${image##*:}"
done
```

### 4. `scripts/generate-private-ecr-values.sh`

Sources the manifest, then generates a YAML file that overrides every image and chart
repository to point at ECR. This is the precision work — each chart has its own values
schema.

```bash
#!/bin/sh
ECR_REGISTRY="$1"
cat <<EOF
# Generated by generate-private-ecr-values.sh for ECR: ${ECR_REGISTRY}
# Pass to aws-bootstrap.sh via --helm-values

charts:
  cert-manager:
    repository: "oci://${ECR_REGISTRY}/charts"
    values:
      image:
        repository: "${ECR_REGISTRY}/mirrored/quay.io/jetstack/cert-manager-controller"
      webhook:
        image:
          repository: "${ECR_REGISTRY}/mirrored/quay.io/jetstack/cert-manager-webhook"
      cainjector:
        image:
          repository: "${ECR_REGISTRY}/mirrored/quay.io/jetstack/cert-manager-cainjector"
      startupapicheck:
        image:
          repository: "${ECR_REGISTRY}/mirrored/quay.io/jetstack/cert-manager-startupapicheck"

  strimzi-kafka-operator:
    repository: "oci://${ECR_REGISTRY}/charts"
    values:
      image:
        registry: "${ECR_REGISTRY}/mirrored"
      # ... strimzi env vars for runtime images

  argo-workflows:
    repository: "oci://${ECR_REGISTRY}/charts"
    values:
      images:
        tag: v3.7.9
      controller:
        image:
          repository: "${ECR_REGISTRY}/mirrored/quay.io/argoproj/workflow-controller"
      server:
        image:
          repository: "${ECR_REGISTRY}/mirrored/quay.io/argoproj/argocli"
      executor:
        image:
          repository: "${ECR_REGISTRY}/mirrored/quay.io/argoproj/argoexec"

  # ... remaining charts

defaultBucketConfiguration:
  bucketOperationImage: "${ECR_REGISTRY}/mirrored/amazon/aws-cli:2.25.11"
EOF
```

### 5. aws-bootstrap.sh integration

New flag: `--push-all-images-to-private-ecr`

This flag:
1. Extracts `scripts/mirror-to-ecr.sh` from the chart tgz (or local repo)
2. Runs it with `$MIGRATIONS_ECR_REGISTRY`
3. Extracts `scripts/generate-private-ecr-values.sh`
4. Runs it to produce the overrides file
5. Passes the overrides file to helm via the existing `--helm-values` mechanism

### 6. Installer job: ECR auth for OCI charts

Add to the top of the installer job script:
```bash
{{- if .Values.ecrAuth }}
aws ecr get-login-password --region $AWS_DEFAULT_REGION | \
  helm registry login --username AWS --password-stdin {{ .Values.ecrAuth.registry }}
{{- end }}
```

The overrides file sets `ecrAuth.registry` when using private ECR.

## Discovery Process (how to build the manifest)

### Step 1: helm template + grep
```bash
for chart in cert-manager strimzi-kafka-operator argo-workflows fluent-bit kube-prometheus-stack; do
  helm pull $chart --repo $REPO --version $VERSION --untar
  helm template test $chart/ 2>/dev/null | grep 'image:' | sort -u
  rm -rf $chart/
done
```

### Step 2: helm-images plugin (cross-check)
```bash
helm plugin install https://github.com/nikhilsbhat/helm-images
helm images get deployment/k8s/charts/aggregates/migrationAssistantWithArgo \
  -f values.yaml -f valuesEks.yaml
```

### Step 3: Runtime image analysis
Some operators pull images not declared in helm values:
- **Strimzi**: pulls kafka images based on `STRIMZI_DEFAULT_KAFKA_IMAGE` env var
- **Prometheus operator**: pulls prometheus based on CRD spec

These need manual identification and addition to the manifest.

### Step 4: Trial and error on isolated subnets
Deploy to isolated subnets, watch for `ImagePullBackOff`, add missing images to manifest.
This should be automated in integ tests.

## Integration Testing

Add a Jenkins pipeline stage (or a new pipeline) that:
1. Deploys to isolated subnets with `--create-vpc-endpoints`
2. Runs `mirror-to-ecr.sh` from the build machine (has internet)
3. Runs `generate-private-ecr-values.sh` to produce overrides
4. Deploys with the overrides
5. Verifies all pods reach `Running` state
6. Any `ImagePullBackOff` is a test failure that indicates a missing image in the manifest

This catches manifest drift whenever chart versions are bumped.

## File Locations

```
deployment/k8s/charts/aggregates/migrationAssistantWithArgo/
  scripts/
    private-ecr-manifest.sh           # Version-locked image & chart list
    discover-images.sh                # Developer tool to regenerate manifest
    mirror-to-ecr.sh                  # Copies images & charts to ECR
    generate-private-ecr-values.sh    # Generates helm values override for ECR
```

All four scripts are packaged in the helm chart tgz.

## What I Need

1. **Access to run `helm template`** for each production subchart to discover images —
   I have the values.yaml, I can do this now.
2. **Strimzi runtime image list** — need to check which kafka images strimzi 0.47.0 pulls.
   Can find this from strimzi docs or by inspecting the operator.
3. **Confirmation on kube-prometheus-stack images** — this chart pulls many sidecar images
   (config-reloader, thanos, etc.). Need to identify which are actually used with our values.
4. **Jenkins pipeline access** — to set up the isolated subnet integ test.

Items 1-3 I can work through with static analysis and trial-and-error. Item 4 would need
your help to wire into the existing pipeline infrastructure.
