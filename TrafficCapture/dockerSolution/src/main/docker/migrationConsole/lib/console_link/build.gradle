plugins {
    id 'base'
}

def openapiOutFile = layout.buildDirectory.file("openapi.json")

def pythonSources = fileTree(dir: projectDir, include: '**/*.py')
def dependencyFiles = files(
    "Pipfile",
    "Pipfile.lock"
).filter { it.exists() }
def venv = layout.projectDir.dir(".venv")

// Needed dereferenced pointer for configuration cache
def projectDirRef = projectDir

tasks.register('preparePipenv') {
    mustRunAfter tasks.named('spotlessCheck')
    mustRunAfter tasks.named('spotlessApply')
    inputs.files(dependencyFiles)
    outputs.dir(venv)

    doLast {
        ['pipenv', 'install', '--dev'].execute(null, projectDirRef).waitFor()
        logger.info("Ran pipenv install")
    }
}

tasks.register('generateOpenApiSpec') {
    dependsOn 'preparePipenv'
    doLast {
        def outputFile = openapiOutFile.get().asFile
        outputFile.parentFile.mkdirs()

        def proc = ['pipenv', 'run', 'python', "-m", 'console_link.scripts.generate_openapi'].execute(null, projectDirRef)
        def stdout = new ByteArrayOutputStream()
        def stderr = new ByteArrayOutputStream()

        proc.waitFor()
        proc.consumeProcessOutput(stdout, stderr)
        def exitCode = proc.waitFor()

        if (exitCode != 0) {
            logger.error("Failed to generate OpenAPI spec:\n${stderr.toString("UTF-8")}")
            throw new GradleException("OpenAPI generation failed with exit code $exitCode")
        }

        outputFile.text = stdout.toString("UTF-8")
        logger.lifecycle("OpenAPI spec generated at ${outputFile}")
    }
    inputs.files(pythonSources)
    inputs.files(dependencyFiles)
    outputs.file(openapiOutFile)
}

clean.doFirst {
    delete venv
}
