import org.opensearch.migrations.common.CommonUtils
import com.bmuschko.gradle.docker.tasks.image.DockerBuildImage

plugins {
    id 'org.opensearch.migrations.java-library-conventions'
    id "com.avast.gradle.docker-compose"
    id 'com.bmuschko.docker-remote-api'
}

// This keeps the build directory name concise (migration_console_staging)
// while allowing the source directory to have a more descriptive name (migrationConsoleStaging)
def migrationConsoleStagingDirName = "staging"
def sourceDirectoryOverrides = [
        "staging": "migrationConsoleStaging"
]

def dockerFilesForExternalServices = [
        "elasticsearch_searchguard": "elasticsearchWithSearchGuard",
        "capture_proxy_base": "captureProxyBase",
        "k8s_config_map_util_scripts": "k8sConfigMapUtilScripts",
        "elasticsearch_client_test_console": "elasticsearchTestConsole",
        "migration_console": migrationConsoleStagingDirName,
        "otel_collector": "otelCollector",
        "grafana": "grafana"
]

dockerFilesForExternalServices.each { dockerImageName, projectName ->
    // Register sync tasks FIRST, outside of any task configuration
    def syncTaskProvider = null
    def syncTaskProviderNoDocker = null

    if (projectName == migrationConsoleStagingDirName) {

        def libraries = [
                project(":libraries:kafkaCommandLineFormatter")
        ]

        def applications = [
                project(":CreateSnapshot"),
                project(":MetadataMigration")
        ]
        // Setup additional sync task which doesn't depend on the base image being built, for other projects to use
        syncTaskProviderNoDocker = getMigrationConsoleSyncTask(project, dockerImageName, projectName, libraries, applications, sourceDirectoryOverrides, false)
        syncTaskProvider = getMigrationConsoleSyncTask(project, dockerImageName, projectName, libraries, applications, sourceDirectoryOverrides, true)
    }

    // Now register the docker build task
    tasks.register("buildDockerImage_${dockerImageName}", DockerBuildImage) {
        if (projectName == migrationConsoleStagingDirName) {
            CommonUtils.dependOnDockerImage(delegate, ":migrationConsole:buildDockerImage_migrationConsoleBase")
            dependsOn syncTaskProvider

            // Realize the task to get directory
            def syncTask = syncTaskProvider.get()
            inputDir = syncTask.destinationDir

            // Calculate hash from the staging directory
            def hashNonce = CommonUtils.calculateDockerHash(project.fileTree(syncTask.destinationDir))
            images.add("migrations/${dockerImageName}:${hashNonce}".toString())
            images.add("migrations/${dockerImageName}:latest".toString())
        } else {
            def sourceDirName = sourceDirectoryOverrides.get(projectName, projectName)
            inputDir = project.file("src/main/docker/${sourceDirName}")
            def hashNonce = CommonUtils.calculateDockerHash(project.fileTree(inputDir))
            images.add("migrations/${dockerImageName}:${hashNonce}".toString())
            images.add("migrations/${dockerImageName}:latest".toString())
        }
    }
}

static TaskProvider<Sync> getMigrationConsoleSyncTask(Project project, String dockerImageName, String projectName, List<Project> libraries, List<Project> applications, Map sourceDirectoryOverrides, boolean dependOnBaseImage) {
    def destDir = "build/docker/${dockerImageName}_${projectName}"
    def taskName = "syncArtifact_${dockerImageName}_${projectName}"
    if (!dependOnBaseImage) {
        taskName = "${taskName}_noDockerBuild"
    }

    def syncTaskProvider = project.tasks.register(taskName, Sync) {
        into destDir
        duplicatesStrategy = DuplicatesStrategy.EXCLUDE

        preserve {
            include 'nodeStaging/**'
        }

        // Applications and Standalone Libraries both have libraries, sync them
        (libraries + applications).each { lib ->
            def applicationDestDir = "staging/${lib.name}/"

            from (lib.files { lib.configurations.runtimeClasspath }) {
                into "${applicationDestDir}/lib"
            }
            // Use map to get output files instead of task reference for configuration cache compatibility
            from (lib.tasks.named('jar').map { it.outputs.files }) {
                into "${applicationDestDir}/lib"
            }
        }

        // Sync application start scripts
        applications.each { app ->
            def applicationDestDir = "staging/${app.name}/"
            // Use map to get output files instead of task reference for configuration cache compatibility
            from (app.tasks.named('startScripts').map { it.outputs.files }) {
                into "${applicationDestDir}/bin"
            }
        }

        // Sync VERSION file
        from (project.rootProject.layout.projectDirectory.file("VERSION"))

        def sourceDirName = sourceDirectoryOverrides.get(projectName, projectName)
        def sourceDir = project.layout.projectDirectory.dir("src/main/docker/${sourceDirName}")
        from(sourceDir.asFileTree.matching {
            exclude("**/build/**", "**/.venv/**")
        })

        // Explicit inputs for incremental build support
        // Track the source Dockerfile and related files
        inputs.dir(sourceDir)
        inputs.file(project.rootProject.layout.projectDirectory.file("VERSION"))
        // Track library and application JARs
        // Use map to get output files instead of task reference for configuration cache compatibility
        (libraries + applications).each { lib ->
            inputs.files(lib.configurations.runtimeClasspath)
            inputs.files(lib.tasks.named('jar').map { it.outputs.files })
        }
        // Track application start scripts
        // Use map to get output files instead of task reference for configuration cache compatibility
        applications.each { app ->
            inputs.files(app.tasks.named('startScripts').map { it.outputs.files })
        }
        outputs.dir(destDir)

        // Collect assemble tasks from libraries and applications
        def assembleTasks = (libraries + applications).collect { it.tasks.named("assemble") }
        dependsOn assembleTasks

        if (dependOnBaseImage) {
            dependsOn "buildDockerImage_elasticsearch_client_test_console"
        }
    }

    return syncTaskProvider
}

def javaContainerServices = [
        "capture_proxy": ":TrafficCapture:trafficCaptureProxyServer",
        "capture_proxy_es": ":TrafficCapture:trafficCaptureProxyServer",
        "traffic_replayer": ":TrafficCapture:trafficReplayer"
]
def baseImageOverrides = [
        "capture_proxy": "capture_proxy_base",
        "capture_proxy_es": "elasticsearch_searchguard",
]
javaContainerServices.each { dockerImageName, projectName ->
    def artifactProject = project(projectName);
    CommonUtils.copyArtifactFromProjectToProjectsDockerStaging(project as Project, artifactProject, dockerImageName)
    CommonUtils.createDockerfile(project, artifactProject, baseImageOverrides[dockerImageName], dockerFilesForExternalServices, dockerImageName)
}

javaContainerServices.forEach { dockerImageName, gradleProjectName ->
    def projectName = project(gradleProjectName).name;
    def dockerBuildDir = "build/docker/${dockerImageName}_${projectName}"
    tasks.register("buildDockerImage_${dockerImageName}", DockerBuildImage) {
        dependsOn "createDockerfile_${dockerImageName}"
        inputDir = project.file("${dockerBuildDir}")
        images.add("migrations/${dockerImageName}:${version}".toString())
        images.add("migrations/${dockerImageName}:latest".toString())
    }
}

dockerCompose {
    def extensionsDir = "src/main/docker/composeExtensions/"
    useComposeFiles =
            ['src/main/docker/docker-compose.yml',
             "${extensionsDir}/" + (project.hasProperty("otel-collector") ?
                     "${project.getProperty('otel-collector')}" :
                     "otel-prometheus-jaeger.yml"),
             "${extensionsDir}" + (project.hasProperty("multiProxy") ? "proxy-multi.yml" : "proxy-single.yml")
            ]
}

tasks.register('buildDockerImages') {
    dependsOn tasks.named('buildDockerImage_k8s_config_map_util_scripts')
    dependsOn tasks.named('buildDockerImage_elasticsearch_searchguard')
    dependsOn tasks.named('buildDockerImage_migration_console')
    dependsOn tasks.named('buildDockerImage_otel_collector')
    dependsOn tasks.named('buildDockerImage_grafana')
    dependsOn tasks.named('buildDockerImage_traffic_replayer')
    dependsOn tasks.named('buildDockerImage_capture_proxy')
    dependsOn tasks.named('buildDockerImage_capture_proxy_es')
}

tasks.getByName('composeUp')
        .dependsOn(tasks.getByName('buildDockerImages'))
