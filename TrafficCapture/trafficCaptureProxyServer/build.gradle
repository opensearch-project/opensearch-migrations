/*
 * This file was generated by the Gradle 'init' task.
 */

plugins {
    id 'org.opensearch.migrations.java-application-conventions'
    id 'io.freefair.lombok'
    id 'com.google.cloud.tools.jib'
}

configurations {
    // This is included to load certs and keys.  Doing it again isn't currently worth it.
    opensearchSecurityPlugin
}

dependencies {
    def openSearch = '2.19.4'
    implementation "org.opensearch:opensearch:${openSearch}"
    implementation "org.opensearch:opensearch-core:${openSearch}"
    implementation "org.opensearch:opensearch-common:${openSearch}"
    implementation "org.opensearch.plugin:opensearch-security:${openSearch}.0"
    opensearchSecurityPlugin "org.opensearch.plugin:opensearch-security:${openSearch}.0"
    implementation files(zipTree("$configurations.opensearchSecurityPlugin.singleFile").matching {
        include "*.jar"
        exclude "slf*.jar"
        exclude "netty*.jar"
        exclude "google-java-format-*.jar"
    })

    implementation project(':TrafficCapture:captureOffloader')
    implementation project(':TrafficCapture:nettyWireLogging')
    implementation project(':TrafficCapture:captureKafkaOffloader')
    implementation project(':coreUtilities')

    implementation libs.protobuf.java
    implementation libs.jackson.core
    implementation libs.jackson.databind
    implementation libs.disruptor
    implementation libs.netty.all
    implementation libs.log4j.api
    implementation libs.log4j.core
    implementation libs.log4j.slf4j2.impl
    implementation libs.jcommander
    implementation libs.slf4j.api


    testImplementation project(':TrafficCapture:captureProtobufs')
    testImplementation testFixtures(project(path: ':testHelperFixtures'))
    testImplementation testFixtures(project(path: ':TrafficCapture:captureOffloader'))
    testImplementation testFixtures(project(path: ':coreUtilities'))
    testImplementation libs.toxiproxy
    testImplementation libs.testcontainers.junit.jupiter
    testImplementation libs.testcontainers.kafka
    testImplementation libs.testcontainers
    testImplementation libs.testcontainers.toxiproxy
}

tasks.withType(Tar){
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

tasks.withType(Zip){
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

application {
    // Define the main class for the application.
    mainClass = 'org.opensearch.migrations.trafficcapture.proxyserver.CaptureProxy'
}

import org.gradle.api.DefaultTask
import org.gradle.api.tasks.InputFiles
import org.gradle.api.tasks.TaskAction
import groovy.io.FileType
import java.util.zip.ZipInputStream

// Custom task type
class VerifyCompatibilityWithJDK11Task extends DefaultTask {
    @InputFiles
    File compiledClassesDir = new File("${project.buildDir}/classes/java/main")

    @InputFiles
    FileTree compileClasspath = project.configurations.compileClasspath.asFileTree

    @InputFiles
    FileTree runtimeClasspath = project.configurations.runtimeClasspath.asFileTree

    @Internal
    boolean isCompatible = true

    @Internal
    HashSet analyzedFiles = new HashSet<File>()

    int getMajorVersion(InputStream inputStream) {
        // Skip first 6 bytes (magic and minor version)
        inputStream.skip(6)
        int majorVersion = (inputStream.read() << 8) | inputStream.read()
        inputStream.close()
        return majorVersion
    }

    void processClassFile(InputStream inputStream, String name, String source) {
        int majorVersion = getMajorVersion(inputStream)
        if (majorVersion > 55) {
            isCompatible = false
            println "Incompatible class file in ${source}: ${name} (Java major version ${majorVersion})"
        }
    }

    void analyzeCompiledClasses() {
        if (compiledClassesDir.exists()) {
            println "Analyzing compiled classes in ${compiledClassesDir}..."
            compiledClassesDir.eachFileRecurse(FileType.FILES) { File file ->
                if (file.name.endsWith('.class')) {
                    file.withInputStream { InputStream inputStream ->
                        processClassFile(inputStream, file.name, compiledClassesDir.toString())
                    }
                }
            }
        } else {
            println "No compiled classes found in ${compiledClassesDir}."
        }
    }

    void analyzeDependencies(FileTree classpathFiles) {
        println "\nAnalyzing dependencies..."
        classpathFiles.files.each { File dependency ->
            if (dependency.name.endsWith(".jar") && !analyzedFiles.contains(dependency)) {
                analyzedFiles.add(dependency)
                def zipStream = new ZipInputStream(new FileInputStream(dependency))
                def entry
                while ((entry = zipStream.nextEntry) != null) {
                    if (entry.name.endsWith(".class")) {
                        // If this is a multi-release jar entry and its version is above 11, skip it.
                        if (entry.name.startsWith("META-INF/versions/")) {
                            def parts = entry.name.split("/")
                            if (parts.size() >= 3 && parts[2].isInteger()) {
                                def versionNumber = parts[2].toInteger()
                                if (versionNumber > 11) {
                                    continue
                                }
                            }
                        }
                        // Copy the entry contents to a temporary file and process it.
                        File tempFile = File.createTempFile("class", ".tmp")
                        tempFile.deleteOnExit()
                        tempFile.withOutputStream { os -> os << zipStream }
                        tempFile.withInputStream { InputStream inputStream ->
                            processClassFile(inputStream, entry.name, dependency.name)
                        }
                    }
                }
                zipStream.close()
            }
        }
    }

    @TaskAction
    void verify() {
        analyzeCompiledClasses()
        analyzeDependencies(runtimeClasspath)

        if (!isCompatible) {
            throw new GradleException("Incompatible class files detected! Ensure all classes are compatible with JDK 11 (major version â‰¤ 55).")
        }
    }
}

tasks.register("verifyCompatibilityWithJDK11", VerifyCompatibilityWithJDK11Task) {
    group = "verification"
    description = "Verify Java major versions of compiled classes and dependencies for compatibility with JDK 11."
    dependsOn tasks.named("assemble")
}

// Add class version verification to slowTest
tasks.named("slowTest") {
    finalizedBy("verifyCompatibilityWithJDK11")
}

tasks.withType(Test).configureEach {
    // Allow lenient line parsing for compatibility with older clients and tests
    systemProperty 'io.netty.handler.codec.http.defaultStrictLineParsing', false
}
